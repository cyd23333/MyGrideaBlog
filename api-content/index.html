{"posts":[{"title":"什么都没有什么都没有什么都没有什么都没有","content":"临时写的一篇文章，这应该算是memo吧 最近在做什么 比赛（我负责人工智能部分）； 整理电脑上的程序（结果来说，汇总成了99G的文件夹，拆机换下来的三星128G NVMe刚好装下了）； 捣鼓我的小NUC（OI520） 竟然没有弄坏我的笔记本本尊！ 最近接触了什么 百度Paddle框架及其衍生物（AI算力实验室、可视化、模型转换） 嘉楠（不是嘉然）K210 Ubuntu 18&amp;20.04 两个LTS（长期资瓷）版本系统 TensorFlow、CUDA &amp; cuDNN MOBAXTerm、SSH前往终端 向日葵和蒲公英 Windows11、Windows7、WindowsPE10、Windows10 想要记录下来的东西 pip install XXXX -i https://pypi.tuna.tsinghua.edu.cn/simple 南向接口（向下连接被管理者）：管理其他厂商网管或设备的接口，即向下提供的接口。北向接口（向上连接管理者）：提供给其他厂家或运营商进行接入和管理的接口，即向上提供的接口。 Windows10专业版安装密钥（Win11也可以用）：VK7JG-NPHTM-C97JM-9MPGT-3V66T Windows7旗舰版安装密钥：TG664-TJ7YK-2VY3K-4YFY6-BCXF4 原版Windows镜像（从官方服务器来源） HEU KMS Activator YYDS 人工智能常见会议和比赛 会议：AAAI、CVPR、ACL、NIPS、ICML、ICLR 国内比赛：中国机器人及人工智能大赛、中国大数据人工智能创新创业大赛 常见神经网络模型框架 TensorFlow（稳定静态）：来自Google PyTorch（支持动态图）：支持动态图模型，也就是define-by-run。来自Facebook Caffe2（轻量级）：可以使用其他框架训练，然后利用Caffe2部署，以节省资源。来自Facebook MXNet（最开源）：原先由Microsoft和Amazon研发，但已捐献给Apache基金会 PaddlePaddle飞桨：狗都不用（不是） Nvidia开发者 飞桨训练（可视化）、转化 如果使用Pytorch训练，那么需要使用--&gt;ONNX（用onnxsim轻量化）--&gt;kmodel 请注意K210可用的nncase版本，不能太新：NNCase 1 训练 cd PaddleDetection python tools/train.py -c configs/ppyolo/ppyolo_tiny_650e_coco.yml //如果要继续训练，在尾部加上-r output/ppyolo_tiny_650e_coco/100 //带有VisualDL记录log输出的训练: python tools/train.py -c configs/ppyolo/ppyolo_mbv3_large_coco.yml --use_vdl=true --vdl_log_dir=vdl_dir/scalar //单张图片的预测 python tools/infer.py -c configs/ppyolo/ppyolo_tiny_650e_coco.yml -o use_gpu=true weights=output/ppyolo_tiny_650e_coco/562.pdparams --infer_img=dataset/motordata/images/20210704_00011.jpg //全路径的预测 python tools/infer.py -c configs/ppyolo/ppyolo_tiny_650e_coco.yml -o use_gpu=true weights=output/ppyolo_tiny_650e_coco/model_final.pdparams --infer_dir=dataset/motordata/images 2 模型导出及转换 2.1 PaddlePaddle Model Output cd PaddleDetection python tools/export_model.py -c configs/ppyolo/ppyolo_tiny_650e_coco.yml \\ -o weights=output/model_final.pdparams \\ TestReader.inputs_def.image_shape=[3,640,640] \\ --output_dir inference_model 以下是静态图版本的导出语句示例 cd PaddleDetection/static python tools/export_model.py -c configs/ppyolo/ppyolo_mobilenet_v3_large.yml \\ -o weights=output/ppyolo_mobilenet_v3_large/best_model.pdparams \\ TestReader.inputs_def.image_shape=[3,640,640] \\ --output_dir inference_model 2.2 PaddleOut --&gt; ONNX 关于转换过程中固定报错的解决方法ISSUE #245 pip install paddle2onnx -i http://mirrors.baidu.com/pypi/simple/ /* 切换PaddleDetection分支 cd PaddleDetection git checkout release/2.1 python setup.py install 切换Paddle2Onnx分支 cd Paddle2ONNX git checkout develop python setup.py install */ paddle2onnx --model_dir inference_model/ppyolo_tiny_650e_coco \\ --model_filename model.pdmodel \\ --params_filename model.pdparams \\ --opset_version 11 \\ --save_file ppyolotiny.onnx 2.3 向Kmodel转换 使用二进制ncc.exe文件进行编译： 利用命令行cd到当前含有ncc程序的目录下。 请先利用CMD运行ncc.exe（不带参数）查看其命令规范。 注意程序版本 =================================================================== 毕设和组会 毕设一般时间安排 下学期10月份定题目（但后期还可以改），下学期结束前（大概12月底）交一份文献综述（大概包括10篇文章，一半以上是英文）和一份文献翻译（选一篇英文文章翻译）。 大四下学期开学大概5周内，交一个“中期报告”。 大概5月份毕设答辩。 可用选题 • 图像指纹（蚂蚁基金） • 图像盲水印与盲写术 • 生成式网络（GAN或VAE）的研究以及将其用于 生成新的训练数据集 • 信号盲分离 ===================================================== 资料搜索1 光响应不均匀性PRNU（硬件模式噪声） 2021.7.24 1） 背景 光响应不均匀性，简称PRNU，是数码相机中模式噪声的来源之一，其产生原因是感光元件CMOS/CCD表面的硅层厚度不一致，那么就可以说，每个成像像素的都会有特征。与DSNU一样，它被视为CCD上像素响应度的变化。然而，当CCD未被照明时，DSNU作为像素响应度的变化出现，而PRNU是照明下的像素变化。 2） 方法 为了刻画PRNU的特征，我们使用相机拍摄由光学衬片产生的多幅均匀场景的图像。我们保持照明水平固定在3.0 cd，因为更亮的光线更容易被相机检测到，我们还检查，以确保相机在拍照前聚焦。我们在三个曝光时间：1/10，1/4和1/2.5，每个曝光100次。 本例子中，PRNU的计算如下： ★ 获取100张图像的平均图像： ★从该平均图像中减去DSNU图像以消除DSNU的贡献； ★获取整个CCD上像素值的空间方差； ★将空间方差除以（ii）中的平均图像，以获得PRNU作为实际像素值的百分比； ★重复不同曝光时间的计算，以比较PRNU； 我们期望PRNU随着光照的增加而增加，因为光照水平的增加将增强图像中像素的光响应差异，并导致更高的PRNU。在我们的测量中，由于Optilinear设备的最大值约为4坎德拉，并且增加照明水平会增加Optilinear产生的照明不均匀性，因此我们选择增加曝光时间来模拟增加照明水平的效果。 3） 结果 可以看到，PRNU和曝光时间之间的关系是近似线性的，这与我们所期望的相符。我们还看到绿色通道的PRNU最高，其次是红色通道，然后是蓝色通道。这与我们对CCD参数的其他测量相对应，它始终显示绿色通道是三个通道中噪声最大的通道（仅针对CCD）； 然而，对于蓝色通道，低曝光值下的PRNU实际上比高曝光值下的PRNU高得多。这可能是由于CCD中的其他噪声源造成的：在三种颜色通道中，蓝色通道的响应度最低，并且在低照度/曝光水平下，来自其他噪声源的贡献将更显著，从而影响获得的PRNU值。 资料搜索2 Facebook在2015年申请的专利 专利号：US 20150124107 社交网络系统存储有关表示真实世界实体的对象以及这些对象之间关系的信息。在社交网络系统中表示的对象包括用户、事件、组或图像。本发明的实施例存储表示用于捕获存储在社交网络系统中的图像的照相机的对象，例如，独立照相机设备以及嵌入在包括电话和笔记本电脑在内的其他设备中的照相机。用户上传的图片从一张图片中提取出来，这张图片描述了相机中用于拍照的相机、镜头刮痕、镜头上的灰尘、相机拍摄图像的特征。从NAT中提取的用于表征相机的信息的示例包括错误的像素位置标签、存储图像的文件中可用的元数据，包括相机的序列号、相机的品牌和型号、记录在图像上的时区，以及类似的元数据、错误的像素、镜头划痕，而相机伪影可能作为用户和在线系统之间的共享秘密，因为先前上传的图像和视频中删除了元数据、错误像素、镜头划痕和相机伪影。可以描述特定相机的其他像素属性包括每种颜色的感光度（或缺少感光度）、每种颜色的最小/最大值以及明亮颜色像素对其他像素的出血。图像也可以通过匹配照片的主题来分析，比如被拍摄的人。镜头伪影可能不在图像传感器上，但在变焦级别指示的图像光路中，可能出现镜头划痕的受影响像素。 组会（July） 语音信号的盲分离（多个人一起说话的语音） 方法一：涉及到STFT得到时频域信号，送入神经网络训练得到mask，作用在原始混合声（时频域）中，再进行短时傅里叶反变换得到输出 方法二：利用Encoder和Decoder（利用神经网络） 傅里叶变换 &amp; 全连接层（相似）————用卷积代替全连接，近似实现傅变换的功能。 毕业设计PPT 1）研究背景与技术路线： （1）研究背景：现有的在做类似的情况和数据（数据图表、工作举例） （2）技术路线：最概述的流程 2）具体步骤及详细内容：*注意进行一些对比 3）结果、展望 思维导图来记录论文 Facebook专利： ASSOCIATING CAMERAS WITH USERS AND OBJECTS IN A SOCIAL NETWORKING SYSTEM Photo Fingerprint 用户设定User Profile 相机设定Camera Profile Action &amp; Connection DATABASE 什么是raw格式的数码照片？ raw格式相当于数码底片，ccd感光的原始数据数据，对于300万像素的数码相机，一个raw文件保存了300万个点的感光数据。严格来说，一个raw文件还不是一张照片，因为还必须提供相应的参数，比如色温（白平衡），锐度，对比度，经过相机内的软件处理，才能成为一张照片。一般来说，一个raw文件包含以下信息，ccd的感光数据，拍摄时相机设置的参数。所以raw格式的图片几乎是保持了一张照片的原始风貌，没有经过什么压缩的处理。 我们在处理raw文件的时候和其他的格式有什么不同？ 在电脑上对raw文件进行处理，实际上相当于相机本身处理拍摄出来的原始图像，如果把这个过程看成“感光元件感光”＋“各种参数处理”＝“照片”。而raw我们可以看做是感光元件感光的原始信号文件，在电脑上是做合成各种参数的处理过程。这样我想就清楚了，而其他格式的图片，都已经是最终的“照片”了，像JPG、TIFF这些都是一样的。 既然RAW文件是原始未压缩的文件，那么为什么还比TIFF这样的压缩文件还小呢？ 传统CCD每个像素只能感光一种颜色，根据感光的强度不同转换成不同的数字，不同的ccd这一数字范围是不同的，早期的8bit，到现在的10bit，12bit。8bit就是一个点感光从最暗到最亮分为256个层次，10bit就是1024个层次，以此类推。假设300万像素每个像素包含10bit的数字信息，那么它的未压缩的raw文件大小： 3,000,000 * 10bit = 30,000,000 bit = 3,750,000byte = 3662.1K = 3.58M 一般相机还会对raw文件进行压缩，是类似zip的无损压缩算法，文件还会更小一些。 Tif是包含真彩色图片文件，所谓真彩色指每个点都包含24bit彩色信息，其中红（R），绿（G），蓝（B）各8bit，这样一个不压缩的300万像素tif文件的大小是： 3,000,000 * 24bit = 9,000,000byte = 3662.1K = 8.58M 资料来源 成像原理？ 无论是CCD还是sCMOS，其基本的原理是一致的： 入射的光子在各个像素中转化为电子； 这些电子接着通过floating diffusion amplifier（FDA）转化为电压； 电压会被再次放大，并通过模数转换器（ADC）变成数字信号； 落到各个像素上的光子被如此转化为数字信号，并最终在电脑上排列显示成图像。 Noise, Dynamic Range and Bit Depth in Digital SLRs --by Emil Martinec ============================================== 2021.8.20 ","link":"https://github.com/cyd23333/post/note20210820/"},{"title":"奇怪的线性表","content":"这是一篇用C语言写就的稀疏多项式的链式存储小练习 Flow：思维导图 Code：稀疏多项式的链式存储与运算 /*陈奕达35320182200117 *Chen Yida 35320182200117 *2020.3.17 +3Day *Use English to avoid Encoding Errors between UTF-8 and ANSI in VSCode. */ #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; typedef struct LNode{ float c; int e; int length; struct LNode* next; }LNode; LNode* LLInit(){ //Func 0 //Create an empty Head Node LNode* LH = (LNode*)malloc(sizeof(LNode)); LH-&gt;next = (LNode*)malloc(sizeof(LNode)); LH-&gt;length = 0; return LH; } void LLReadCreate(FILE* fp, LNode* LHA);// FUNC A void LLSort(LNode* LHB);// FUNC B LNode* LLAdd(LNode* LA, LNode* LB, int op);// FUNC C // LNode* LLMinus(LNode* LA, LNode* LB);// FUNC D LNode* LLDiff(LNode* LHE);// FUNC E void LLPrint(LNode* LHF);// FUNC F void LLOperate(FILE* fp, LNode* LA, LNode* LB, int Operation); int main(){ int FSOne = 1; int LoopCount = 1; while(1){ printf(&quot;*************************************************\\n\\tThis is MainProgram Loop: %d\\nPlease select the function you want to use:\\n&quot;, LoopCount); //printf(&quot;1) Plus LA+LB\\n2) Minus LA-LB\\n3) Derivation for LA and LB\\n\\t\\tOther Input------&gt;&gt; Exit Program\\nYour choose:&quot;); printf(&quot; Enter 1 to Execute........Enter 5 to EXIT.\\nYour choose:&quot;); scanf(&quot;%d&quot;,&amp;FSOne); printf(&quot;*************************************************\\n&quot;); LNode* LA = LLInit(); LNode* LB = LLInit(); switch (FSOne){ case 1:{ // FILE* fp = fopen(&quot;W:/C Worksp/2021 DSAA/week3_210317/ydwk3.txt&quot;,&quot;r&quot;); FILE* fp = fopen(&quot;ydwk3.txt&quot;,&quot;r&quot;); rewind(fp); printf(&quot;*************************************************\\n&quot;); printf(&quot;\\n********************Poly Group 1:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 1); printf(&quot;\\n********************Poly Group 2:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 2); printf(&quot;\\n**************Poly Group 2 ( REVERSED ):**************\\n\\n&quot;); LNode *LX = LLAdd(LB, LA, 2); printf(&quot;Now Printing the Reversed Minus Result in Poly Group2:\\n\\n&quot;); LLPrint(LX); free(LX); printf(&quot;\\n********************Poly Group 3:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 1); printf(&quot;\\n********************Poly Group 4:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 1); printf(&quot;\\n********************Poly Group 5:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 1); printf(&quot;\\n********************Poly Group 6:********************\\n\\n&quot;); LLOperate(fp, LA, LB, 1); free(LA); free(LB); fclose(fp); }break; case 2:{ printf(&quot;\\nSingle Func Test: LA-LB\\n&quot;); }break; case 3:{ printf(&quot;\\nSingle Func Test: diff(LA)\\tdiff(LB)\\n&quot;); }break; default:{ printf(&quot;\\n886~\\n&quot;); goto outter; } } LoopCount ++; } outter: system(&quot;pause&quot;); return 0; } void LLReadCreate(FILE* fp, LNode* LHA){ //Func A //Reading from text and then create LL..... float coef = 0.0; int expf = 0; LHA-&gt;length = 0; LNode* p, *ptr; p = LHA; while(1){ fscanf(fp, &quot;%f %d&quot;, &amp;coef, &amp;expf); if(coef==0 &amp;&amp; expf==0){ if(p == LHA){ ptr = (LNode*)malloc(sizeof(LNode)); ptr-&gt;c = ptr-&gt;e = 0; p-&gt;next = ptr; ptr-&gt;next = NULL; LHA-&gt;length = 1; break; } else{ p-&gt;next = NULL; break; } }// (0,0) if(coef != 0){ p-&gt;next = (LNode*)malloc(sizeof(LNode)); ptr = p; p = p-&gt;next; p-&gt;c = coef; p-&gt;e = expf; LHA-&gt;length ++; } } printf(&quot;Done. Read and Created LL from the text file.\\n&quot;); } void LLSort(LNode* LHB){ //Func B //Descending Order //// Considering using &lt;stdlib.h&gt; qsort() if(LHB-&gt;length == 0){ printf(&quot;The List is EMPTY! Please check!!\\n&quot;); return; } if(LHB-&gt;length == 1) return; LNode *p, *q, *ptr; p = LHB-&gt;next; q = p-&gt;next; float coef = 0; int expf = 0; while(1){ while(q != NULL){ if (p-&gt;e &lt; q-&gt;e){ coef = p-&gt;c; expf = p-&gt;e; p-&gt;c = q-&gt;c; p-&gt;e = q-&gt;e; q-&gt;c = coef; q-&gt;e = expf; } else if(p-&gt;e == q-&gt;e){ p-&gt;c = p-&gt;c + q-&gt;c; ptr-&gt;next = q-&gt;next; LHB-&gt;length --; } ptr = q; q = q-&gt;next; } p = p-&gt;next; q = p-&gt;next;// Once after a SUBCYCLE, reset the position of the ptr* q if (p-&gt;next == NULL) break; } } LNode* LLAdd(LNode* LA, LNode* LB, int op){ LNode* p, *q, *ptr; LNode* LC = LLInit(); LC-&gt;length = 0; LNode* pc = LLInit(); p = LA-&gt;next; q = LB-&gt;next; if ( (LA-&gt;length==0 &amp;&amp; LB-&gt;length==0) || (LA-&gt;next==NULL &amp;&amp; LB-&gt;next==NULL) ){ printf(&quot;These two LL are ALL EMPTY! Please check!&quot;); return LC; }// Robustness pc = LC-&gt;next; float coef = 0.00; while(q!=NULL &amp;&amp; p!=NULL){ if(p-&gt;c==0){ p = p-&gt;next; continue; } if(q-&gt;c==0){ q = q-&gt;next; continue; } if(p-&gt;e &lt; q-&gt;e){ pc-&gt;c = q-&gt;c; pc-&gt;e = q-&gt;e; LC-&gt;length ++; q = q-&gt;next; pc-&gt;next = (LNode*)malloc(sizeof(LNode)); ptr = pc; pc = pc-&gt;next; } else if(p-&gt;e &gt; q-&gt;e){ pc-&gt;c = p-&gt;c; pc-&gt;e = p-&gt;e; LC-&gt;length ++; p = p-&gt;next; pc-&gt;next = (LNode*)malloc(sizeof(LNode)); ptr = pc; pc = pc-&gt;next; } else{ if (op == 1) coef = p-&gt;c + q-&gt;c; if (op == 2) coef = p-&gt;c - q-&gt;c; if(abs(coef) &lt; 1e-6){ p = p-&gt;next; q = q-&gt;next; } else{ pc-&gt;c = coef; pc-&gt;e = p-&gt;e; LC-&gt;length ++; p = p-&gt;next; q = q-&gt;next; pc-&gt;next = (LNode*)malloc(sizeof(LNode)); ptr = pc; pc = pc-&gt;next; } } } // End of while(q!=NULL &amp;&amp; p!=NULL) if (p == NULL){ while(q != NULL){ pc-&gt;c = q-&gt;c; pc-&gt;e = q-&gt;e; LC-&gt;length ++; q = q-&gt;next; ptr = pc; pc-&gt;next = (LNode*)malloc(sizeof(LNode)); pc = pc-&gt;next; } } if (q == NULL){ while(p != NULL){ pc-&gt;c = p-&gt;c; pc-&gt;e = p-&gt;e; LC-&gt;length ++; p = p-&gt;next; ptr = pc; pc-&gt;next = (LNode*)malloc(sizeof(LNode)); pc = pc-&gt;next; } } ptr-&gt;next = NULL; free(pc); return LC; } LNode* LLDiff(LNode* LHE){ LNode* p, *ptr, *LE, *pe; LE = LLInit(); pe = LE-&gt;next; p = LHE; if(p-&gt;next == NULL){ printf(&quot;\\nCurrent LL is EMPTY!\\n&quot;); return NULL; } while(p-&gt;next != NULL){ p = p-&gt;next; if(p-&gt;e == 0) continue; pe-&gt;c = p-&gt;c*p-&gt;e; pe-&gt;e = p-&gt;e - 1; LE-&gt;length ++; pe-&gt;next = (LNode*)malloc(sizeof(LNode)); ptr = pe; pe = pe-&gt;next; } ptr-&gt;next = NULL; return LE; } void LLPrint(LNode* LHF){ //Func F //Print as formatted LL LNode* p; if(LHF-&gt;length != 0 || LHF != NULL){ p = LHF-&gt;next; printf(&quot;This LL is %d long &quot;,LHF-&gt;length); while (p != NULL){ printf(&quot;, %.2f,%d &quot;, p-&gt;c, p-&gt;e); p = p-&gt;next; } printf(&quot;\\n&quot;); } else printf(&quot;The List is EMPTY!\\n&quot;); } void LLOperate(FILE* fp, LNode* LA, LNode* LB, int Operation){ // Do some DEFINE: plus 1 // minus 2 LLReadCreate(fp,LA); LLReadCreate(fp,LB); if(LA-&gt;length != 0){ printf(&quot;\\nGoing to Print the first LL:\\n&quot;); LLSort(LA); LLPrint(LA); }else printf(&quot;\\nThe first LL is EMPTY!! Please check!\\n&quot;); if(LB-&gt;length != 0){ printf(&quot;\\nGoing to Print the second LL:\\n&quot;); LLSort(LB); LLPrint(LB); }else printf(&quot;\\nThe second LL is EMPTY!! Please check!\\n&quot;); LNode* LC = LLAdd(LA,LB,Operation); printf(&quot;\\nNow We Print the Calculate Result LL:\\n&quot;); LLPrint(LC); if(Operation == 1) printf(&quot;P.S. While we Swap these two poly, they will give the SAME Result\\n&quot;); LNode* LD = LLDiff(LA); LNode* LE = LLDiff(LB); if(LD-&gt;length!=0 &amp;&amp; LE-&gt;length!=0){ printf(&quot;\\nNow We Print the Diff Result of the first LL:\\n&quot;); LLPrint(LD); printf(&quot;\\nNow We Print the Diff Result of the second LL:\\n&quot;); LLPrint(LE); } else if(LD-&gt;length!=0){ printf(&quot;\\nThe second LL is EMPTY.\\nNow We Print the Diff Result of the first LL:\\n&quot;); LLPrint(LD); } else if(LE-&gt;length!=0){ printf(&quot;\\nThe first LL is EMPTY\\nNow We Print the Diff Result of the second LL:\\n&quot;); LLPrint(LE); } else printf(&quot;\\nThe two LL are ALL EMPTY\\n&quot;); } // End of This File :) 注释自己看哈哈哈哈 当时因为VS Code中文显示相关问题，所以干脆全用的英文写的程序XD ","link":"https://github.com/cyd23333/post/DSAA_LL_1/"},{"title":"Step-0 in TensorFlow","content":"本文理应是TensorFlow的第一篇笔记，URL=tensorflow-1 人工智能（Artificial Intelligence） 机器学习（Machine Learning） 有监督的学习（Supervised L） 分类Classification（二元、多元分类） 回归分析（Regression） 无监督的学习（Unsupervised L） 聚类（Clustering） 增强式学习（Reinforcement L） Q-Learning TD Sarsa 深度学习（Deep Learning）（DNN CNN RNN） TensorFlow * 低级的深度学习链接库 * 功能强大效率高，支持各种平台 * 学习门槛高 Keras * 高级的深度学习链接库 * 对初学者学习门槛低 * 容易的建模、训练、预测 所以先学习Keras（以TF作为后端）之后，再学习纯粹地使用TensorFlow，不失为一种渐进的学习方式。 我，Anaconda，安装！ 清华镜像开源站 in IPv4 安装路径随意，唯一要注意的是，为了节省时间精力并降低血压，请务必： 勾选上Add …… to PATH 勾选上Add …… to PATH!!!!!!!!!!!!!!! 我，TensorFlow，配置！ 1 在开始配置前先简单提一下如何设置Anaconda虚拟环境的存储位置。 参考自：知乎 https://zhuanlan.zhihu.com/p/266161343 1. CMD中输入：conda info 2. 查看envs directories项的第一个路径，此为默认路径 3. 用记事本打开.condarc文件，在最后加入： envs_dirs: - X:\\（要修改到的默认路径） 2 警告！本方法会让你的系统中凭空多一组Anaconda组件（乖巧） 在Windows10下建立TensorFlow GPU环境 一、程序下载 CUDA CUDA in Nvidia cuDNN cuDNN in Nvidia Python Python org 二、安装和配置环境 CUDA 装就好了，需要Nv家的显卡 cuDNN 将压缩包的cuda文件夹解压到X:\\（路径自订） 系统环境变量PATH中新增一条：X:\\cuda\\bin Python（CMD或PowerShell，以Python 3.8.5为例） conda create --name tensorflow-gpu python=3.8.5 anaconda @ 建立名为tensorflow-gpu的虚拟环境，并同时安装其他python软件包 &gt; y @ ……安装完成 activate tensorflow-gpu pip install tensorflow-gpu pip install keras jupyter notebook 这样以后就能用了2333 祝好运。 ","link":"https://github.com/cyd23333/post/tensorflow-1/"},{"title":"Markdown Writing","content":"本篇提到Markdown语法。作工具书用。 首先，Gridea编辑器对Markdown语法的支持有些不一样，所以很多效果我都需要渲染网页并预览，才知道效果233 所以有可能会打错（小声） ","link":"https://github.com/cyd23333/post/markdown-writing/"},{"title":"路径一览","content":"摘要。所以，不要停下来啊。 游戏Game 游戏不愧是我喜欢的东西。 我会分享一些被我游玩过的游戏的“玩后感”，同时推荐一些 （松鼠病收集者的） 游戏。 各种类型的游戏我都能玩，但是因为晕3D的情况，不少半途而废。 学习笔记LearnSth 学习真不愧是我喜欢的东西。 在很长一段时间内，或许学习仍然是我的主要工作。 我将会把OneNote上、书上、笔记上的东西再次整理到网站上。 更加简略、更加精炼、更不易懂。可能这就是我认为的，把书读薄。 电脑操作技能PCSkill 电脑真真不愧是我喜欢的东西。 我有大概十几年的电脑经验，但是好像没啥专业软件的知识。 大致都来自《电脑报》、《微型计算机》、《电脑迷》、《电脑爱好者》。 或许还能算上《少年电脑世界》、《Geek》、《新潮电子》之类的杂志 （不过，买了十几年的杂志，还不知邮政订阅为何物233） 正文结束啦 祝我生日快乐。 printf exit 套娃 套娃 套娃 套娃 套娃 套娃 套娃 套娃 套娃 套娃 套娃 ","link":"https://github.com/cyd23333/post/lu-jing-yi-lan/"},{"title":"Test #1","content":"喵呜。这是一篇用来测试功能的文章。 得益于beta版本的Gridea作用，有很多令人不能理解、前后不一致的错误。 ###而且网页渲染也太！费！时！了！ _欸嘿，一个新格式_ 最后整一张图片上去： ","link":"https://github.com/cyd23333/post/test-1/"},{"title":"关于一切","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 这个页面也能在页面顶部的工具栏搞到~ 不了不了 🏠 关于本站 喵呜，这部分还在编写233 反正就是自说自话的地方233 👨‍💻 博主是谁 缺锌达！ ⛹ 兴趣爱好 玩电脑和拆电脑 不过，我可不是宅 📬 联系我呀 邮箱：cyd100001@outlook.com 微博：微博 网易云：网抑云 哔哩哔哩：Bilibili 这地方搞个评论区会不会好一点（在学了在学了） ","link":"https://github.com/cyd23333/post/about/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://github.com/cyd23333/post/hello-gridea/"}]}